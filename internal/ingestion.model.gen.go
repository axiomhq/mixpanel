// Package internal provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package internal

import (
	"encoding/json"
	"fmt"

	"github.com/pkg/errors"
)

// ErrorResponse defines model for error-response.
type ErrorResponse struct {

	// Response error description.
	Error *string `json:"error,omitempty"`

	// Response status value.
	Status *string `json:"status,omitempty"`
}

// EventForm defines model for event-form.
type EventForm struct {

	// If present, Mixpanel will return a `content-type: text/javascript` with a body that calls a function
	// by value provided. This is useful for creating local callbacks to a successful track call in JavaScript.
	Callback *string `json:"callback,omitempty"`

	// Events describe actions that take place within your product. An event contains properties that describe the action.
	Data EventObject `json:"data"`

	// If present and equal to 1, Mixpanel will serve a 1x1 transparent pixel image as a response to the request.
	// This is useful for adding [Pixel Tracking](https://en.wikipedia.org/wiki/Web_beacon)
	// in places that javascript is not supported.
	Img *int32 `json:"img,omitempty"`

	// If present and equal to 1, Mixpanel will use the ip address of the incoming request
	// as a distinct_id if none is provided.
	// This is different from providing a `properties.ip` value in the Event Object.
	Ip *int32 `json:"ip,omitempty"`

	// If present, Mixpanel will serve a redirect to the given url as a response to the request.
	// This is useful to add link tracking in notifications.
	Redirect *string `json:"redirect,omitempty"`

	// If present and equal to 1, Mixpanel will respond with a JSON Object describing the success
	// or failure of the tracking call. The returned object will have two keys: `status`,
	// with the value 1 on success and 0 on failure, and `error`,
	// with a string-valued error message if the request wasn't successful.
	Verbose *int32 `json:"verbose,omitempty"`
}

// Events describe actions that take place within your product. An event contains properties that describe the action.
type EventObject struct {

	// The name of the action to track
	Event string `json:"event"`

	// A dictionary of properties to hold metadata about your event
	Properties *EventObject_Properties `json:"properties,omitempty"`
}

// A dictionary of properties to hold metadata about your event
type EventObject_Properties struct {

	// A random 36 character string of hyphenated alphanumeric characters that is unique to an event. Hyphen (-) is optional. $insert_id can contain less than 36 characters, but any string longer than 36 characters will be truncated. If an $insert_id contains non-alphanumeric or non-hyphen characters then Mixpanel replaces it with a random alphanumeric value.
	InsertId *string `json:"$insert_id,omitempty"`

	// The value of distinct_id will be treated as a string, and used to uniquely identify a user associated with your event. If you provide a distinct_id property with your events, you can track a given user through funnels and distinguish unique users for retention analyses. You should always send the same distinct_id when an event is triggered by the same user.
	DistinctId *string `json:"distinct_id,omitempty"`

	// An IP address string (e.g. "127.0.0.1") associated with the event. This is used for adding geolocation data to events, and should only be required if you are making requests from your backend. If ip is absent (and ip=1 is not provided as a URL parameter), Mixpanel will ignore the IP address of the request.
	Ip *interface{} `json:"ip,omitempty"`

	// The time that this event occurred. If present, the value should be a unix timestamp (seconds since midnight, January 1st, 1970 - UTC). If this property is not included in your request, Mixpanel will use the time the event arrives at the server. If you're using our mobile SDKs, it will be set automatically for you.
	Time *int `json:"time,omitempty"`

	// The Mixpanel token associated with your project. You can find your Mixpanel token in the project settings dialog in the Mixpanel app. Events without a valid token will be ignored.
	Token                string                 `json:"token"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// The value `1` indicates all data objects provided are valid.
// This does not signify a valid project token or secret.
// The value `0` indicates one or more data objects in the body are invalid.

type ResponseStatusFlag int

// Verbose response on demand.
type VerboseResponse struct {

	// Error description if the request wasn't successful.
	Error *string `json:"error,omitempty"`

	// The value `1` indicates all data objects provided are valid.
	// This does not signify a valid project token or secret.
	// The value `0` indicates one or more data objects in the body are invalid.
	Status *ResponseStatusFlag `json:"status,omitempty"`
}

// Getter for additional properties for EventObject_Properties. Returns the specified
// element and whether it was found
func (a EventObject_Properties) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for EventObject_Properties
func (a *EventObject_Properties) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for EventObject_Properties to handle AdditionalProperties
func (a *EventObject_Properties) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["$insert_id"]; found {
		err = json.Unmarshal(raw, &a.InsertId)
		if err != nil {
			return errors.Wrap(err, "error reading '$insert_id'")
		}
		delete(object, "$insert_id")
	}

	if raw, found := object["distinct_id"]; found {
		err = json.Unmarshal(raw, &a.DistinctId)
		if err != nil {
			return errors.Wrap(err, "error reading 'distinct_id'")
		}
		delete(object, "distinct_id")
	}

	if raw, found := object["ip"]; found {
		err = json.Unmarshal(raw, &a.Ip)
		if err != nil {
			return errors.Wrap(err, "error reading 'ip'")
		}
		delete(object, "ip")
	}

	if raw, found := object["time"]; found {
		err = json.Unmarshal(raw, &a.Time)
		if err != nil {
			return errors.Wrap(err, "error reading 'time'")
		}
		delete(object, "time")
	}

	if raw, found := object["token"]; found {
		err = json.Unmarshal(raw, &a.Token)
		if err != nil {
			return errors.Wrap(err, "error reading 'token'")
		}
		delete(object, "token")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for EventObject_Properties to handle AdditionalProperties
func (a EventObject_Properties) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.InsertId != nil {
		object["$insert_id"], err = json.Marshal(a.InsertId)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '$insert_id'"))
		}
	}

	if a.DistinctId != nil {
		object["distinct_id"], err = json.Marshal(a.DistinctId)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling 'distinct_id'"))
		}
	}

	if a.Ip != nil {
		object["ip"], err = json.Marshal(a.Ip)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling 'ip'"))
		}
	}

	if a.Time != nil {
		object["time"], err = json.Marshal(a.Time)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling 'time'"))
		}
	}

	object["token"], err = json.Marshal(a.Token)
	if err != nil {
		return nil, errors.Wrap(err, fmt.Sprintf("error marshaling 'token'"))
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}
